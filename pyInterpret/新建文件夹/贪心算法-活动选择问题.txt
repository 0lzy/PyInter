#活动选择问题
#假设有n个活动，这些活动要占用一片场地，而场地在某时刻只能供一个活动使用
#每个活动有一个开始时间s(i)和结束时间f(i)(题目钟时间以整数表示)，表示活动在[s(i),f(i))区间占用场地
#问安排哪些活动能够使该场地举办的活动的个数最多？

#贪心结论：最先结束的活动一定是最优解的一部分
#证明：假设a是所有活动中最先结束的活动，b是最优解中最先结束的活动。
    #如果a=b，结论成立
    #如果a!=b,则b的结束时间一定晚于a的结束时间，则此时用a替换掉最优解中的b，a一定不与最优解中的其他活动时间重叠，因此替换后的解也是最优解。

s=[1,3,0,5,3,5,6,8,8,2,12]
f=[4,5,6,7,9,9,10,11,12,14,16]
f.sort()    #保证活动是按照结束时间排好序的
activities=list(zip(s,f))    #其中s为每个活动的开始时间，f为结束时间
#activities.sort(key=lambda x:x[1])  #相当于f.sort()

def activity_selection(a):
    res=[a[0]]    #先把第一个结束时间最早的活动放到新列表中
    for i in range(1,len(a)):    #再选择其他剩余活动中结束时间最早且不与之前最优解中已发生的活动中时间冲突的活动
        if a[i][0]>=res[-1][1]:    #时间不冲突;下一个活动的开始时间要大于上一个活动(最后一个入选)的结束时间
            res.append(a[i])
    return res

print(activity_selection(activities))