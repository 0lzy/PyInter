#二叉树的顺序存储方式
#父节点和左孩子节点的编号下标有什么关系？
#如果父亲节点在顺序表中的下标是i，那么他的左孩子下标为2*i+1
#则他的右孩子下标为2i+2
#若已知孩子的下标j(不管是左孩子还是右孩子)，则父节点的下标为(j-1)//2

#堆是一种特殊的完全二叉树
#大根堆：一棵完全二叉树，满足任一节点都比子孩子节点大
#小根堆：一棵完全二叉树，满足任一节点都比子孩子节点小

#堆的向下调整：当根节点的左右子树都是堆时，但自身不是堆，可以通过一个向下的调整来将其变成一个堆

#堆排序过程
#从最底层开始
#1.建立一个堆（农村包围城市）
#2.得到堆顶元素
#3.去掉堆顶，将堆最后一个元素放到堆顶，此时可以通过一次向下调整重新使堆有序
#4.堆顶元素为第二大元素
#5.重复步骤三，直到堆变空

#用大根堆实现
def sift(li,low,high):  #向下调整函数
    #假设除了他自己外，其他子树全是堆
    """
    li:列表
    low：堆的根节点位置
    high：堆的最后一个元素位置（！也可以是整个堆的最后一个元素 ）
    """
    i=low   #最开始指向根节点
    j=2*i+1  #为i的左孩子
    tmp=li[low]  #把根节点存起来，i是变的，这里不能写li[i]
    while j<=high and j+1<=high:   #只要j这个位置有数，就一直循环（不要让j超过最后一层）
                                #保证有右孩子，防止越界
        if li[j+1]>li[j]:
            j=j+1    #找出两个孩子中最大的一个，j指向右孩子
        if li[j]>tmp:
            li[i]=li[j]  #j的位置为空了
            i=j        #往下看一层
            j=j*2+1    #孩子也跟着往下
        else: #li[j]<=tmp
            li[i]=tmp   #把tmp放在某一级领导的位置上
            break
    else:
        li[i]=tmp  #如果j越界了，i就是指最后一层了，把tmp放到叶子节点上

#堆排序
def heap_sort(li):
    #如果孩子的下标是i（不管是左孩子还是右孩子），那么他的根节点下标就是（i-1）//2
    #如果线性存储的二叉树，他的最后一个叶子节点的下标为n-1，那么他的根节点的下标就是(n-2)//2
    n=len(li)
    #堆排序从最底层开始，最底层堆的根节点下标为（n-2)//2
    for i in range((n-2)//2,-1,-1):
        #i代表建堆的时候调整的部分下标根的下标
        sift(li,i,n-1)
    #建堆完成了
    print(li)
    for i in range(n-1,-1,-1): 
        #i指向堆的最后一个元素
        li[0],li[i]=li[i],li[0]  #让棋子上去（去掉堆顶）
        sift(li,0,i-1)   #通过调整重新让其成为堆（不过这里high是i-1，因为第i个位置已经存储了最大的元素）
    print(li)

#时间复杂度O(nlogn)


li=list(range(1000))
import random
random.shuffle(li)
heap_sort(li)


#堆排序内置模块
import heapq

li=list(range(100))
random.shuffle(li)
print(li)
heapq.heapify(li)  #建堆
print(li)
li_=list()
for i in range(len(li)):
    a=heapq.heappop(li)
    print(a,end=',') #弹出一个最小的元素
    li_.append(a)
print(li_)


